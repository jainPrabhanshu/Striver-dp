// Given a ‘N’ * ’M’ maze with obstacles, count and return the number of unique paths to reach the right-bottom cell from the top-left cell. A cell in the given maze has a value '-1' if it is a blockage or dead-end, else 0. From a given cell, we are allowed to move to cells (i+1, j) and (i, j+1) only. Since the answer can be large, print it modulo 10^9 + 7.

int mod = 1e9 + 7;
int path(int i, int j, vector< vector<int>> &mat,vector<vector<int>>&dp){
    if(i ==0 && j==0){
        return 1;
    }
    if(i<0 || j<0){
        return 0;
    }
    if(mat[i][j]==-1){
        return 0;
    }
    if(dp[i][j]!= -1){
        return dp[i][j];
    }
    int up = path(i-1,j,mat,dp);
    int left = path(i,j-1,mat,dp);
    return dp[i][j] = (up+left)%mod;
}
int mazeObstacles(int n, int m, vector< vector< int> > &mat) {
    // Write your code here
    // int dp[n][m];
    // for(int i=0;i<n;i++){
    //     for(int j=0;j<m;j++){
    //         if(mat[i][j]==-1 ){
    //             dp[i][j] = 0;
    //         }
    //         else if(i==0 && j==0){
    //             dp[i][j] = 1;
    //         }
    //         else{
    //             int up =0 ,left=0;
    //             if(i>0){
    //                 up = dp[i-1][j];
    //             }
    //             if(j>0){
    //                 left = dp[i][j-1];
    //             }
    //             dp[i][j] = (up + left)%mod;
    //         }
    //     }
    // }
    // return dp[n-1][m-1];
    vector<vector<int>>dp(n,vector<int>(m,-1));
    return path(n-1,m-1,mat,dp);
}